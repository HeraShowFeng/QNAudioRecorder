{"version":3,"file":"bundle.js","sources":["../src/index.js","../src/Loudness.js"],"sourcesContent":["import Loudness from './Loudness'\n\nconst VOLUME_INTERVAL = 100 // ms\nlet volumeIntervalID\n\nconst AudioContext = window.AudioContext || window.webkitAudioContext\nconst audioContext = new AudioContext({ latencyHint: 'interactive' })\nconst loudness = new Loudness(audioContext)\n\nexport async function start(cb) {\n  clearInterval(volumeIntervalID)\n  audioContext.resume()\n\n  volumeIntervalID = setInterval(() => {\n    cb(loudness.getLoudness())\n  }, VOLUME_INTERVAL)\n}\n\nexport function stop() {\n  clearInterval(volumeIntervalID)\n  loudness.release()\n}\n","/**\n * @reference https://github.com/LLK/scratch-audio/blob/a049deba23013ced81ce21b1ba6ae2c4e9714eb3/src/Loudness.js\n */\nexport default class Loudness {\n  /**\n   * Instrument and detect a loudness value from a local microphone.\n   * @param {AudioContext} audioContext - context to create nodes from for\n   *     detecting loudness\n   * @constructor\n   */\n  constructor(audioContext) {\n    /**\n     * AudioContext the mic will connect to and provide analysis of\n     * @type {AudioContext}\n     */\n    this.audioContext = audioContext\n\n    /**\n     * Are we connecting to the mic yet?\n     * @type {Boolean}\n     */\n    this.connectingToMic = false\n\n    /**\n     * microphone, for measuring loudness, with a level meter analyzer\n     * @type {MediaStreamSourceNode}\n     */\n    this.mic = null\n  }\n\n  /**\n   * Get the current loudness of sound received by the microphone.\n   * Sound is measured in RMS and smoothed.\n   * Some code adapted from Tone.js: https://github.com/Tonejs/Tone.js\n   * @return {number} loudness scaled 0 to 100\n   */\n  getLoudness() {\n    // The microphone has not been set up, so try to connect to it\n    if (!this.mic && !this.connectingToMic) {\n      this.connectingToMic = true // prevent multiple connection attempts\n      navigator.mediaDevices\n        .getUserMedia({ audio: true })\n        .then((stream) => {\n          this.audioStream = stream\n          this.mic = this.audioContext.createMediaStreamSource(stream)\n          this.analyser = this.audioContext.createAnalyser()\n          this.mic.connect(this.analyser)\n          this.micDataArray = new Float32Array(this.analyser.fftSize)\n        })\n        .catch((err) => {\n          console.warn(err)\n        })\n    }\n\n    // If the microphone is set up and active, measure the loudness\n    if (this.mic && this.audioStream && this.audioStream.active) {\n      this.analyser.getFloatTimeDomainData(this.micDataArray)\n      let sum = 0\n      // compute the RMS of the sound\n      for (let i = 0; i < this.micDataArray.length; i++) {\n        sum += Math.pow(this.micDataArray[i], 2)\n      }\n      let rms = Math.sqrt(sum / this.micDataArray.length)\n      // smooth the value, if it is descending\n      if (this._lastValue) {\n        rms = Math.max(rms, this._lastValue * 0.6)\n      }\n      this._lastValue = rms\n\n      // Scale the measurement so it's more sensitive to quieter sounds\n      rms *= 1.63\n      rms = Math.sqrt(rms)\n      // Scale it up to 0-100 and round\n      rms = Math.round(rms * 100)\n      // Prevent it from going above 100\n      rms = Math.min(rms, 100)\n\n      rms = rms / 100\n      return rms\n    }\n\n    // if there is no microphone input, return 0\n    return 0\n  }\n\n  release() {\n    this.connectingToMic = false\n    if (this.mic) {\n      this.mic.disconnect()\n      this.mic = null\n    }\n    if (this.audioStream) {\n      this.audioStream.getTracks().forEach((t) => t.stop())\n      this.audioStream = undefined\n    }\n    if (this.analyser) {\n      this.analyser.disconnect()\n      this.analyser = undefined;\n    }\n  }\n}\n"],"names":["volumeIntervalID","Loudness","audioContext","this","connectingToMic","mic","getLoudness","navigator","mediaDevices","getUserMedia","audio","then","stream","_this","audioStream","createMediaStreamSource","analyser","createAnalyser","connect","micDataArray","Float32Array","fftSize","err","console","warn","active","getFloatTimeDomainData","sum","i","length","Math","pow","rms","sqrt","_lastValue","max","round","min","release","disconnect","getTracks","forEach","t","stop","undefined","window","AudioContext","webkitAudioContext","latencyHint","loudness","cb","clearInterval","resume","setInterval"],"mappings":"6OAGIA,ECAiBC,0BAOnB,WAAYC,GAKVC,KAAKD,aAAeA,EAMpBC,KAAKC,iBAAkB,EAMvBD,KAAKE,IAAM,gCASbC,YAAA,sBAmBE,GAjBKH,KAAKE,KAAQF,KAAKC,kBACrBD,KAAKC,iBAAkB,EACvBG,UAAUC,aACPC,aAAa,CAAEC,OAAO,IACtBC,KAAK,SAACC,GACLC,EAAKC,YAAcF,EACnBC,EAAKR,IAAMQ,EAAKX,aAAaa,wBAAwBH,GACrDC,EAAKG,SAAWH,EAAKX,aAAae,iBAClCJ,EAAKR,IAAIa,QAAQL,EAAKG,UACtBH,EAAKM,aAAe,IAAIC,aAAaP,EAAKG,SAASK,iBAE9C,SAACC,GACNC,QAAQC,KAAKF,MAKfnB,KAAKE,KAAOF,KAAKW,aAAeX,KAAKW,YAAYW,OAAQ,CAC3DtB,KAAKa,SAASU,uBAAuBvB,KAAKgB,cAG1C,IAFA,IAAIQ,EAAM,EAEDC,EAAI,EAAGA,EAAIzB,KAAKgB,aAAaU,OAAQD,IAC5CD,GAAOG,KAAKC,IAAI5B,KAAKgB,aAAaS,GAAI,GAExC,IAAII,EAAMF,KAAKG,KAAKN,EAAMxB,KAAKgB,aAAaU,QAgB5C,OAdI1B,KAAK+B,aACPF,EAAMF,KAAKK,IAAIH,EAAuB,GAAlB7B,KAAK+B,aAE3B/B,KAAK+B,WAAaF,EAGlBA,GAAO,KACPA,EAAMF,KAAKG,KAAKD,GAEhBA,EAAMF,KAAKM,MAAY,IAANJ,IAEjBA,EAAMF,KAAKO,IAAIL,EAAK,MAER,IAKd,YAGFM,QAAA,WACEnC,KAAKC,iBAAkB,EACnBD,KAAKE,MACPF,KAAKE,IAAIkC,aACTpC,KAAKE,IAAM,MAETF,KAAKW,cACPX,KAAKW,YAAY0B,YAAYC,QAAQ,SAACC,UAAMA,EAAEC,SAC9CxC,KAAKW,iBAAc8B,GAEjBzC,KAAKa,WACPb,KAAKa,SAASuB,aACdpC,KAAKa,cAAW4B,SD3FhB1C,EAAe,IADA2C,OAAOC,cAAgBD,OAAOE,oBACb,CAAEC,YAAa,gBAC/CC,EAAW,IAAIhD,EAASC,oBAEFgD,OAAI,OAC9BC,cAAcnD,GACdE,EAAakD,SAEbpD,EAAmBqD,YAAY,WAC7BH,EAAGD,EAAS3C,gBAZQ,uBAOxB,sDAUE6C,cAAcnD,GACdiD,EAASX"}